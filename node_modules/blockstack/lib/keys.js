"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const cryptoRandom_1 = require("./encryption/cryptoRandom");
const sha2Hash_1 = require("./encryption/sha2Hash");
const hashRipemd160_1 = require("./encryption/hashRipemd160");
const config_1 = require("./config");
/**
 *
 * @param numberOfBytes
 *
 * @ignore
 */
function getEntropy(arg) {
    if (!arg) {
        arg = 32;
    }
    return cryptoRandom_1.randomBytes(arg);
}
exports.getEntropy = getEntropy;
/**
* @ignore
*/
function makeECPrivateKey() {
    const keyPair = bitcoinjs_lib_1.ECPair.makeRandom({ rng: getEntropy });
    return keyPair.privateKey.toString('hex');
}
exports.makeECPrivateKey = makeECPrivateKey;
/**
* @ignore
*/
function publicKeyToAddress(publicKey) {
    const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');
    const publicKeyHash160 = hashRipemd160_1.hashRipemd160(sha2Hash_1.hashSha256Sync(publicKeyBuffer));
    const result = bitcoinjs_lib_1.address.toBase58Check(publicKeyHash160, bitcoinjs_lib_1.networks.bitcoin.pubKeyHash);
    return result;
}
exports.publicKeyToAddress = publicKeyToAddress;
/**
* @ignore
*/
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');
    const keyPair = bitcoinjs_lib_1.ECPair.fromPrivateKey(privateKeyBuffer);
    return keyPair.publicKey.toString('hex');
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
/**
 * Time
 * @private
 * @ignore
 */
function hexStringToECPair(skHex) {
    const ecPairOptions = {
        network: config_1.config.network.layer1,
        compressed: true
    };
    if (skHex.length === 66) {
        if (skHex.slice(64) !== '01') {
            throw new Error('Improperly formatted private-key hex string. 66-length hex usually '
                + 'indicates compressed key, but last byte must be == 1');
        }
        return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);
    }
    else if (skHex.length === 64) {
        ecPairOptions.compressed = false;
        return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);
    }
    else {
        throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');
    }
}
exports.hexStringToECPair = hexStringToECPair;
/**
 *
 * @ignore
 */
function ecPairToHexString(secretKey) {
    const ecPointHex = secretKey.privateKey.toString('hex');
    if (secretKey.compressed) {
        return `${ecPointHex}01`;
    }
    else {
        return ecPointHex;
    }
}
exports.ecPairToHexString = ecPairToHexString;
/**
 * Creates a bitcoin address string from an ECPair
 * @private
 * @ignore
 */
function ecPairToAddress(keyPair) {
    const sha256 = sha2Hash_1.hashSha256Sync(keyPair.publicKey);
    const hash160 = hashRipemd160_1.hashRipemd160(sha256);
    return bitcoinjs_lib_1.address.toBase58Check(hash160, keyPair.network.pubKeyHash);
}
exports.ecPairToAddress = ecPairToAddress;
//# sourceMappingURL=keys.js.map