"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
function isSubtleCryptoAvailable() {
    return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
}
exports.isSubtleCryptoAvailable = isSubtleCryptoAvailable;
function isNodeCryptoAvailable(withFeature) {
    try {
        const resolvedResult = require.resolve('crypto');
        if (!resolvedResult) {
            return false;
        }
        // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require
        const cryptoModule = require('crypto');
        if (!cryptoModule) {
            return false;
        }
        if (withFeature) {
            const features = withFeature(cryptoModule);
            return features;
        }
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.isNodeCryptoAvailable = isNodeCryptoAvailable;
exports.NO_CRYPTO_LIB = 'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
// Make async for future version which may lazy load.
// eslint-disable-next-line @typescript-eslint/require-await
function getCryptoLib() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (isSubtleCryptoAvailable()) {
            return {
                lib: crypto.subtle,
                name: 'subtleCrypto'
            };
        }
        else {
            try {
                // eslint-disable-next-line max-len
                // eslint-disable-next-line import/no-nodejs-modules,no-restricted-modules,global-require,@typescript-eslint/no-var-requires
                const nodeCrypto = require('crypto');
                return {
                    lib: nodeCrypto,
                    name: 'nodeCrypto'
                };
            }
            catch (error) {
                throw new Error(exports.NO_CRYPTO_LIB);
            }
        }
    });
}
exports.getCryptoLib = getCryptoLib;
//# sourceMappingURL=cryptoUtils.js.map