"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ripemd160_min_1 = require("ripemd160-min");
const cryptoUtils_1 = require("./cryptoUtils");
class Ripemd160PolyfillDigest {
    digest(data) {
        const instance = new ripemd160_min_1.default();
        instance.update(data);
        const hash = instance.digest();
        if (Array.isArray(hash)) {
            return Buffer.from(hash);
        }
        else {
            return Buffer.from(hash.buffer);
        }
    }
}
exports.Ripemd160PolyfillDigest = Ripemd160PolyfillDigest;
class NodeCryptoRipemd160Digest {
    constructor(nodeCryptoCreateHash) {
        this.nodeCryptoCreateHash = nodeCryptoCreateHash;
    }
    digest(data) {
        try {
            return this.nodeCryptoCreateHash('rmd160').update(data).digest();
        }
        catch (error) {
            try {
                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();
            }
            catch (_err) {
                console.log(error);
                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');
                const polyfill = new Ripemd160PolyfillDigest();
                return polyfill.digest(data);
            }
        }
    }
}
exports.NodeCryptoRipemd160Digest = NodeCryptoRipemd160Digest;
function createHashRipemd160() {
    const nodeCryptoCreateHash = cryptoUtils_1.isNodeCryptoAvailable(nodeCrypto => {
        if (typeof nodeCrypto.createHash === 'function') {
            return nodeCrypto.createHash;
        }
        return false;
    });
    if (nodeCryptoCreateHash) {
        return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);
    }
    else {
        return new Ripemd160PolyfillDigest();
    }
}
exports.createHashRipemd160 = createHashRipemd160;
function hashRipemd160(data) {
    const hash = createHashRipemd160();
    return hash.digest(data);
}
exports.hashRipemd160 = hashRipemd160;
//# sourceMappingURL=hashRipemd160.js.map