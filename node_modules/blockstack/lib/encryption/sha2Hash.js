"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const sha_js_1 = require("sha.js");
const cryptoUtils_1 = require("./cryptoUtils");
class NodeCryptoSha2Hash {
    constructor(createHash) {
        this.createHash = createHash;
    }
    digest(data, algorithm = 'sha256') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const result = this.createHash(algorithm)
                    .update(data)
                    .digest();
                return Promise.resolve(result);
            }
            catch (error) {
                console.log(error);
                console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);
                return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
            }
        });
    }
}
exports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;
class WebCryptoSha2Hash {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    digest(data, algorithm = 'sha256') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let algo;
            if (algorithm === 'sha256') {
                algo = 'SHA-256';
            }
            else if (algorithm === 'sha512') {
                algo = 'SHA-512';
            }
            else {
                throw new Error(`Unsupported hash algorithm ${algorithm}`);
            }
            try {
                const hash = yield this.subtleCrypto.digest(algo, data);
                return Buffer.from(hash);
            }
            catch (error) {
                console.log(error);
                console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);
                return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
            }
        });
    }
}
exports.WebCryptoSha2Hash = WebCryptoSha2Hash;
function createSha2Hash() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cryptoLib = yield cryptoUtils_1.getCryptoLib();
        if (cryptoLib.name === 'subtleCrypto') {
            return new WebCryptoSha2Hash(cryptoLib.lib);
        }
        else {
            return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);
        }
    });
}
exports.createSha2Hash = createSha2Hash;
function hashSha256Sync(data) {
    const hash = new sha_js_1.sha256();
    hash.update(data);
    return hash.digest();
}
exports.hashSha256Sync = hashSha256Sync;
function hashSha512Sync(data) {
    const hash = new sha_js_1.sha512();
    hash.update(data);
    return hash.digest();
}
exports.hashSha512Sync = hashSha512Sync;
//# sourceMappingURL=sha2Hash.js.map