{"version":3,"file":"index.esm.js","sources":["../src/internal-state.ts","../src/changeHandler.ts","../src/prettyPrint.ts","../src/atom.ts","../src/error-messages.ts","../src/throwIfNotAtom.ts","../src/deref.ts","../src/getValidator.ts","../src/set.ts","../src/setValidator.ts","../src/swap.ts"],"sourcesContent":["import { Atom } from \"./atom\";\nimport { AtomConstructorOptions, DeepImmutable } from \"./internal-types\";\n\nlet nextAtomUid = 0;\nconst stateByAtomId: Record<number, DeepImmutable<any>> = Object.create(null);\nconst validatorByAtomId: Record<number, NonNullable<AtomConstructorOptions<any>[\"validator\"]>> = Object.create(null);\nconst changeHandlersByAtomId: Record<number, Record<string, (s: any) => void>> = {};\n\n/** @ignore */\nexport function _useNextAtomId() {\n  return nextAtomUid++;\n}\n\n/** @ignore */\nexport function _getState<S>(atom: Atom<S>): S {\n  return stateByAtomId[atom[\"$$id\"]];\n}\n/** @ignore */\nexport function _setState<S>(atom: Atom<S>, state: S): void {\n  stateByAtomId[atom[\"$$id\"]] = state;\n}\n\n/** @ignore */\nexport function _getValidator<S>(atom: Atom<S>): NonNullable<AtomConstructorOptions<S>[\"validator\"]> {\n  return validatorByAtomId[atom[\"$$id\"]];\n}\n\n/** @ignore */\nexport function _setValidator<S>(atom: Atom<S>, validator: NonNullable<AtomConstructorOptions<S>[\"validator\"]>): void {\n  validatorByAtomId[atom[\"$$id\"]] = validator;\n}\n\n/** @ignore */\nexport function _initChangeHandlerDict(atom: Atom<any>) {\n  changeHandlersByAtomId[atom[\"$$id\"]] = {};\n}\n\n/** @ignore */\nexport function _addChangeHandler<S>(\n  atom: Atom<S>,\n  key: string,\n  handler: (states: { previous: S; current: S }) => void\n) {\n  if (typeof changeHandlersByAtomId[atom[\"$$id\"]][key] === \"function\") {\n    throw new Error(\n      `Change handler already registered for key \"${key}\" on ${atom}.\\nRemove the existing handler before registering a new one.`\n    );\n  }\n  changeHandlersByAtomId[atom[\"$$id\"]][key] = handler;\n}\n\n/** @ignore */\nexport function _removeChangeHandler<S>(atom: Atom<S>, key: string) {\n  delete changeHandlersByAtomId[atom[\"$$id\"]][key];\n}\n\n/** @ignore */\nexport function _runChangeHandlers<S>(atom: Atom<S>, previous: S, current: S) {\n  Object.keys(changeHandlersByAtomId[atom[\"$$id\"]]).forEach(k => {\n    if (typeof changeHandlersByAtomId[atom[\"$$id\"]][k] === \"function\") {\n      changeHandlersByAtomId[atom[\"$$id\"]][k]({ previous, current });\n    }\n  });\n}\n","import { Atom } from \"./atom\";\nimport { _addChangeHandler, _removeChangeHandler } from \"./internal-state\";\n\n/**\n * Registers a function to be run each time the state of `atom` changes.\n *\n * Will throw an Error if `key` is already taken by another handler.\n *\n * @example\n```js\n\nimport {Atom, addChangeHandler, swap} from '@libre/atom'\n\nconst countAtom = Atom.of({ count: 0 })\n\naddChangeHandler(countAtom, \"log\", ({current, previous}) => {\n  console.log(previous, current)\n})\n\nswap(countAtom, (state) => ({ count: state.count + 1 }))\n\n\n// stdout logs:\n// { count: 0 }\n// { count: 1 }\n\n```\n */\nexport function addChangeHandler<S>(\n  atom: Atom<S>,\n  key: string,\n  handler: (states: { previous: S; current: S }) => void\n) {\n  _addChangeHandler(atom, key, handler);\n}\n\n/**\n * Deletes the `key` and the handler associated with `key` so that it not longer runs\n * when the state of `atom` changes.\n *\n * @example\n```js\n\nimport {Atom, addChangeHandler, removeChangeHandler, swap} from '@libre/atom'\n\nconst countAtom = Atom.of({ count: 0 })\n\naddChangeHandler(countAtom, \"log\", ({current, previous}) => {\n  console.log(previous, current)\n})\n\nswap(countAtom, (state) => ({ count: state.count + 1 }))\n\n// stdout logs:\n// { count: 0 }\n// { count: 1 }\n\nremoveChangeHandler(atom, \"log\")\n\nswap(countAtom, (state) => ({ count: state.count + 1 }))\n\n// nothing is logged\n```\n */\nexport function removeChangeHandler<S>(atom: Atom<S>, key: string) {\n  _removeChangeHandler(atom, key);\n}\n","/** @ignore */\nexport function prettyPrint(val: any): string {\n  return JSON.stringify(val, null, \"  \");\n}\n","import { _getState, _initChangeHandlerDict, _setState, _setValidator, _useNextAtomId } from \"./internal-state\";\nimport { AtomConstructorOptions, DeepImmutable } from \"./internal-types\";\nimport { prettyPrint } from \"./prettyPrint\";\n\n/**\n * A data structure useful for providing a controlled, predictable mechanism for mutability.\n * Allows multiple components of a program to share read/write access to some state in such\n * a way that no component can mutate another component's current reference to the state in\n * the middle of some process or asynchronous operation.\n *\n */\n\nexport class Atom<S = any> {\n  /**\n   * Constructs a new instance of [[Atom]] with its internal state\n   * set to `state`.\n   *\n   * @param S the type of the value being set as an [[Atom]]'s internal state\n   * @example\n```js\n\nimport { Atom } from '@libre/atom'\n\nconst a1 = Atom.of(0)\nconst a2 = Atom.of(\"zero\")\nconst a3 = Atom.of({ count: 0 })\n```\n   */\n  public static of<S>(state: S, options?: AtomConstructorOptions<S>): Atom<S> {\n    return new Atom(state, options);\n  }\n\n  /** @ignore */\n  public readonly [\"$$id\"]: number;\n\n  /** @ignore */\n  private constructor(state: S, { validator }: AtomConstructorOptions<S> = {}) {\n    validator = validator || (() => true);\n    if (!validator(state as DeepImmutable<S>)) {\n      const errMsg = `Atom initialized with invalid state:\\n\\n${prettyPrint(\n        state\n      )}\\n\\naccording to validator function:\\n${validator}\\n\\n`;\n      const err = Error(errMsg);\n      err.name = \"AtomInvalidStateError\";\n\n      throw err;\n    }\n    Object.defineProperty(this, \"$$id\", { value: _useNextAtomId() });\n    _setState(this, state);\n    _setValidator(this, validator);\n    _initChangeHandlerDict(this);\n    return this;\n  }\n  /** @ignore */\n  public toString(): string {\n    return `Atom<${prettyPrint(_getState(this))}>`;\n  }\n  /** @ignore */\n  public inspect(): string {\n    return this.toString();\n  }\n}\n","/** @ignore */\nexport const expectedAtomButGot = \"Expected an Atom instances, but got:\";\n","import { Atom } from \"./atom\";\nimport * as ErrorMsgs from \"./error-messages\";\nimport { _getState } from \"./internal-state\";\nimport { prettyPrint } from \"./prettyPrint\";\n\n/** @ignore */\nexport function throwIfNotAtom<S>(atom: Atom<S>): void | never {\n  if (!(atom instanceof Atom)) {\n    throw TypeError(`${ErrorMsgs.expectedAtomButGot}\\n\\n${prettyPrint(atom)}`);\n  }\n}\n","import { Atom } from \"./atom\";\nimport { _getState } from \"./internal-state\";\nimport { DeepImmutable } from \"./internal-types\";\nimport { throwIfNotAtom } from \"./throwIfNotAtom\";\n\n/**\n * Dereferences (i.e. \"*reads*\") the current state of an [[Atom]]. The dereferenced value\n * should ___not___ be mutated.\n *\n * @param <S> the type of `atom`'s inner state\n *\n * @example\n```js\n\nimport {Atom, deref} from '@libre/atom'\n\nconst stateAtom = Atom.of({ count: 0 })\n\nderef(stateAtom) // => { count: 0 }\n```\n */\nexport function deref<S>(atom: Atom<S>): DeepImmutable<S> {\n  throwIfNotAtom(atom);\n  return _getState(atom) as DeepImmutable<S>;\n}\n","import { Atom } from \"./atom\";\nimport { _getValidator } from \"./internal-state\";\nimport { AtomConstructorOptions } from \"./internal-types\";\n\nimport { throwIfNotAtom } from \"./throwIfNotAtom\";\n\n/**\n * Gets `atom`'s validator function\n *\n * @param <S> the type of `atom`'s inner state\n *\n * @example\n```js\n\nimport {Atom, deref, getValidator, swap} from '@libre/atom'\n\nconst atom = Atom.of({ count: 0 }, { validator: (state) => isEven(state.count) })\nconst validator = getValidator(atom)\nvalidator({ count: 3 }) // => false\nvalidator({ count: 2 }) // => true\n```\n */\n\nexport function getValidator<S>(atom: Atom<S>): NonNullable<AtomConstructorOptions<any>[\"validator\"]> {\n  throwIfNotAtom(atom);\n  return _getValidator(atom);\n}\n","import { Atom } from \"./atom\";\nimport { deref } from \"./deref\";\nimport { _getValidator, _runChangeHandlers, _setState } from \"./internal-state\";\nimport { DeepImmutable } from \"./internal-types\";\nimport { prettyPrint } from \"./prettyPrint\";\nimport { throwIfNotAtom } from \"./throwIfNotAtom\";\n\n/**\n * Sets `atom`s state to `nextState`.\n *\n * It is equivalent to `swap(atom, () => newState)`.\n *\n * @param <S> the type of `atom`'s inner state\n * @param atom an instance of [[Atom]]\n * @param nextState the value to which to set the state; it should be the same type/interface as current state\n *\n  * @example\n```js\n\nimport {Atom, deref, set} from '@libre/atom'\n\nconst atom = Atom.of({ count: 0 })\n\nset(atom, { count: 100 })\nderef(atom) // => { count: 100 }\n```\n */\n\nexport function set<S>(atom: Atom<S>, nextState: S): void {\n  throwIfNotAtom(atom);\n  const validator = _getValidator(atom);\n  const didValidate = validator(nextState as DeepImmutable<S>);\n  if (!didValidate) {\n    const errMsg = `Attempted to set the state of\\n\\n${atom}\\n\\nwith:\\n\\n${prettyPrint(\n      nextState\n    )}\\n\\nbut it did not pass validator:\\n${validator}\\n\\n`;\n    const err = Error(errMsg);\n    err.name = \"AtomInvalidStateError\";\n\n    throw err;\n  } else {\n    const prevState = deref(atom);\n    _setState(atom, nextState);\n    _runChangeHandlers(atom, prevState as S, nextState);\n  }\n}\n","import { Atom } from \"./atom\";\nimport { _getState, _setValidator } from \"./internal-state\";\nimport { AtomConstructorOptions } from \"./internal-types\";\nimport { throwIfNotAtom } from \"./throwIfNotAtom\";\n\n/**\n * Sets the `validator` for `atom`. `validator` must be a pure function of one argument,\n * which will be passed the intended new state on any state change. If the new state is\n * unacceptable, `validator` should return false or throw an exception. If the current state\n * is not acceptable to the new validator, an exception will be thrown and the validator will\n * not be changed.\n *\n * @param <S> the type of `atom`'s inner state\n *\n * @example\n```js\n\nimport {Atom, deref, setValidator, set} from '@libre/atom'\nimport { _setValidator } from './internal-state';\n\nconst atom = Atom.of({ count: 0 }, {validator: (state) => isNumber(state.count) })\nsetValidator(atom, (state) => isOdd(state.count)) // Error; new validator rejected\nset(atom, {count: \"not number\"}) // Error; new state not set\nsetValidator(atom, (state) => isEven(state.count)) // All good\nset(atom, {count: 2}) // All good\n\n```\n */\n\nexport function setValidator<S>(atom: Atom<S>, validator: NonNullable<AtomConstructorOptions<any>[\"validator\"]>): void {\n  throwIfNotAtom(atom);\n  if (!validator(_getState(atom))) {\n    const errMsg = `Could not set validator on\\n\\n${atom}\\n\\nbecause current state would be invalid according to new validator:\\n${validator}\\n\\n`;\n    const err = Error(errMsg);\n    err.name = \"AtomInvalidStateError\";\n    throw err;\n  } else {\n    _setValidator(atom, validator);\n  }\n}\n","import { Atom } from \"./atom\";\nimport { _getState, _getValidator, _runChangeHandlers, _setState } from \"./internal-state\";\nimport { DeepImmutable } from \"./internal-types\";\nimport { prettyPrint } from \"./prettyPrint\";\nimport { throwIfNotAtom } from \"./throwIfNotAtom\";\n\n/**\n * Swaps `atom`'s state with the value returned from applying `updateFn` to `atom`'s\n * current state. `updateFn` should be a pure function and ___not___ mutate `state`.\n *\n * @param <S> the type of `atom`'s inner state\n * @param atom an instance of [[Atom]]\n * @param updateFn a pure function that takes the current state and returns the next state; the next state should be of the same type/interface as the current state;\n *\n * @example\n * ```jsx\n *\n *import {Atom, swap} from '@libre/atom'\nimport {prettyPrint} from './prettyPrint'\n *\n *const stateAtom = Atom.of({ count: 0 })\n *const increment = () => swap(stateAtom, (state) => ({\n *  count: state.count + 1\n *}));\n * ```\n */\nexport function swap<S>(atom: Atom<S>, updateFn: (state: S) => S): void {\n  throwIfNotAtom(atom);\n  const prevState = _getState(atom);\n  const nextState = updateFn(prevState);\n  const validator = _getValidator(atom);\n  const didValidate = validator(nextState as DeepImmutable<S>);\n  if (!didValidate) {\n    const errMsg = `swap updateFn\\n${updateFn}\\n\\nattempted to swap the state of\\n\\n${atom}\\n\\nwith:\\n\\n${prettyPrint(\n      nextState\n    )}\\n\\nbut it did not pass validator:\\n${validator}\\n\\n`;\n    const err = Error(errMsg);\n    err.name = \"AtomInvalidStateError\";\n\n    throw err;\n  } else {\n    _setState(atom, nextState);\n    _runChangeHandlers(atom, prevState as S, nextState);\n  }\n}\n"],"names":["ErrorMsgs.expectedAtomButGot"],"mappings":"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"}